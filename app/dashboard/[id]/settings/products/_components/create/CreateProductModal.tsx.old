"use client";

import React, { useEffect, useMemo, useState } from "react";
import { toast } from "react-hot-toast";
import { ChevronDown, ChevronRight, X, Plus } from "lucide-react";

import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";

import { createBrowserClient } from "@/utils/supabase/client";
import { PRODUCT_IMAGE_BUCKET } from "@/lib/images";

function slugify(input: string) {
  return input
    .toLowerCase()
    .trim()
    .replace(/['"]/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");
}

function safeExtFromFile(file: File) {
  const type = (file.type || "").toLowerCase();
  if (type.includes("jpeg")) return "jpg";
  if (type.includes("jpg")) return "jpg";
  if (type.includes("png")) return "png";
  if (type.includes("webp")) return "webp";
  if (type.includes("gif")) return "gif";
  if (type.includes("avif")) return "avif";
  if (type.includes("heic") || type.includes("heif")) return "heic";

  const name = file.name || "";
  const i = name.lastIndexOf(".");
  const ext = i >= 0 ? name.slice(i + 1).toLowerCase() : "jpg";
  return ext || "jpg";
}

function buildObjectPath(productId: string, index1Based: number, ext: string) {
  return `products/${productId}/${index1Based}.${ext}`;
}

async function safeReadJson(res: Response) {
  const text = await res.text();
  if (!text) return null;
  try {
    return JSON.parse(text);
  } catch {
    return { ok: false, error: { code: "NON_JSON_RESPONSE", message: text.slice(0, 300) } };
  }
}

function moneyToCents(value: string) {
  const n = Number(value);
  if (!Number.isFinite(n)) return null;
  return Math.round(n * 100);
}

function CollapsibleSection({
  title,
  open,
  onToggle,
  children,
  description,
}: {
  title: string;
  open: boolean;
  onToggle: () => void;
  description?: string;
  children: React.ReactNode;
}) {
  return (
    <div className="rounded-xl border border-[hsl(var(--border))]">
      <button
        type="button"
        onClick={onToggle}
        className="w-full flex items-center justify-between px-4 py-3 text-left"
      >
        <div>
          <div className="text-sm font-semibold">{title}</div>
          {description ? (
            <div className="text-xs text-[hsl(var(--muted-foreground))] mt-0.5">{description}</div>
          ) : null}
        </div>
        <span className="text-[hsl(var(--muted-foreground))]">
          {open ? <ChevronDown size={18} /> : <ChevronRight size={18} />}
        </span>
      </button>

      {open ? <div className="px-4 pb-4 pt-1">{children}</div> : null}
    </div>
  );
}

type CategoryNode = {
  id: string;
  name?: string;
  title?: string;
  label?: string;
  slug?: string;
  children?: CategoryNode[];
};

type CollectionRow = {
  id: string;
  name?: string;
  title?: string;
  label?: string;
  slug?: string;
  is_home_section?: boolean;
  is_homepage?: boolean;
};

type ImageWithAlt = {
  file: File;
  alt: string;
  preview: string;
  position: number;
  isPrimary: boolean;
};

type SizeOption = {
  id: string;
  value: string;
};

type ColorOption = {
  id: string;
  name: string;
  hex: string;
};

// ✨ NEW: Material option
type MaterialOption = {
  id: string;
  value: string; // "95%Polyester+5%Elastane", "100% Cotton", etc.
};

// ✨ NEW: Made In option
type MadeInOption = {
  id: string;
  value: string; // "USA", "China", etc.
};

type VariantInput = {
  id: string;
  title: string;
  sku: string;
  selectedSizes: string[];
  selectedColors: string[];
  selectedMaterials: string[];    // ✨ NEW
  selectedMadeIn: string[];       // ✨ NEW
  customOptions: Record<string, string>;
  weight_grams: string;
  price_override: string;
  initial_stock: string;
};

export default function CreateProductModal({
  open,
  onOpenChange,
  onCreated,
}: {
  open: boolean;
  onOpenChange: (v: boolean) => void;
  onCreated: () => void;
}) {
  const [title, setTitle] = useState("");
  const [slug, setSlug] = useState("");
  const [price, setPrice] = useState("0.00");
  const [description, setDescription] = useState("");

  const [images, setImages] = useState<ImageWithAlt[]>([]);
  
  const [availableSizes, setAvailableSizes] = useState<SizeOption[]>([]);
  const [availableColors, setAvailableColors] = useState<ColorOption[]>([]);
  const [availableMaterials, setAvailableMaterials] = useState<MaterialOption[]>([]); // ✨ NEW
  const [availableMadeIn, setAvailableMadeIn] = useState<MadeInOption[]>([]);         // ✨ NEW
  
  const [variants, setVariants] = useState<VariantInput[]>([]);

  const [secImagesOpen, setSecImagesOpen] = useState(false);
  const [secVariantsOpen, setSecVariantsOpen] = useState(false);
  const [secCategoriesOpen, setSecCategoriesOpen] = useState(false);
  const [secCollectionsOpen, setSecCollectionsOpen] = useState(false);

  const [availableCategories, setAvailableCategories] = useState<CategoryNode[]>([]);
  const [selectedCategoryIds, setSelectedCategoryIds] = useState<string[]>([]);

  const [availableCollections, setAvailableCollections] = useState<CollectionRow[]>([]);
  const [selectedCollectionIds, setSelectedCollectionIds] = useState<string[]>([]);

  const [creating, setCreating] = useState(false);

  const cents = useMemo(() => moneyToCents(price), [price]);

  const autoSlug = () => setSlug(slugify(title));

  const reset = () => {
    setTitle("");
    setSlug("");
    setPrice("0.00");
    setDescription("");
    setImages([]);
    setAvailableSizes([]);
    setAvailableColors([]);
    setAvailableMaterials([]);
    setAvailableMadeIn([]);
    setVariants([]);
    setSelectedCategoryIds([]);
    setSelectedCollectionIds([]);

    setSecImagesOpen(false);
    setSecVariantsOpen(false);
    setSecCategoriesOpen(false);
    setSecCollectionsOpen(false);
  };

  useEffect(() => {
    if (!open) return;

    (async () => {
      try {
        const catRes = await fetch("/api/categories?include=tree");
        const catJson = await safeReadJson(catRes);
        if (catRes.ok && catJson?.ok) setAvailableCategories(catJson.data || []);
      } catch {}

      try {
        const colRes = await fetch("/api/collections");
        const colJson = await safeReadJson(colRes);
        if (colRes.ok && colJson?.ok) setAvailableCollections(colJson.data || []);
      } catch {}
    })();
  }, [open]);

  // SIZE HANDLERS
  const addSize = () => {
    const id = Math.random().toString(36).substring(7);
    setAvailableSizes([...availableSizes, { id, value: "" }]);
  };

  const updateSize = (id: string, value: string) => {
    setAvailableSizes(availableSizes.map(s => (s.id === id ? { ...s, value } : s)));
  };

  const removeSize = (id: string) => {
    setAvailableSizes(availableSizes.filter(s => s.id !== id));
    setVariants(variants.map(v => ({
      ...v,
      selectedSizes: v.selectedSizes.filter(sizeId => sizeId !== id)
    })));
  };

  // COLOR HANDLERS
  const addColor = () => {
    const id = Math.random().toString(36).substring(7);
    setAvailableColors([...availableColors, { id, name: "", hex: "#000000" }]);
  };

  const updateColor = (id: string, field: "name" | "hex", value: string) => {
    setAvailableColors(availableColors.map(c => (c.id === id ? { ...c, [field]: value } : c)));
  };

  const removeColor = (id: string) => {
    setAvailableColors(availableColors.filter(c => c.id !== id));
    setVariants(variants.map(v => ({
      ...v,
      selectedColors: v.selectedColors.filter(colorId => colorId !== id)
    })));
  };

  // ✨ MATERIAL HANDLERS
  const addMaterial = () => {
    const id = Math.random().toString(36).substring(7);
    setAvailableMaterials([...availableMaterials, { id, value: "" }]);
  };

  const updateMaterial = (id: string, value: string) => {
    setAvailableMaterials(availableMaterials.map(m => (m.id === id ? { ...m, value } : m)));
  };

  const removeMaterial = (id: string) => {
    setAvailableMaterials(availableMaterials.filter(m => m.id !== id));
    setVariants(variants.map(v => ({
      ...v,
      selectedMaterials: v.selectedMaterials.filter(matId => matId !== id)
    })));
  };

  // ✨ MADE IN HANDLERS
  const addMadeIn = () => {
    const id = Math.random().toString(36).substring(7);
    setAvailableMadeIn([...availableMadeIn, { id, value: "" }]);
  };

  const updateMadeIn = (id: string, value: string) => {
    setAvailableMadeIn(availableMadeIn.map(m => (m.id === id ? { ...m, value } : m)));
  };

  const removeMadeIn = (id: string) => {
    setAvailableMadeIn(availableMadeIn.filter(m => m.id !== id));
    setVariants(variants.map(v => ({
      ...v,
      selectedMadeIn: v.selectedMadeIn.filter(madeInId => madeInId !== id)
    })));
  };

  // IMAGE HANDLERS
  const handleFilesSelected = (fileList: FileList | null) => {
    if (!fileList) return;

    const newImages: ImageWithAlt[] = Array.from(fileList).map((file, idx) => ({
      file,
      alt: "",
      preview: URL.createObjectURL(file),
      position: images.length + idx,
      isPrimary: images.length === 0 && idx === 0,
    }));

    setImages([...images, ...newImages]);
  };

  const updateImageAlt = (index: number, alt: string) => {
    const updated = [...images];
    updated[index].alt = alt;
    setImages(updated);
  };

  const removeImage = (index: number) => {
    const updated = images.filter((_, i) => i !== index);
    updated.forEach((img, i) => {
      img.position = i;
      if (i === 0 && !updated.some(x => x.isPrimary)) {
        img.isPrimary = true;
      }
    });
    setImages(updated);
  };

  const setPrimaryImage = (index: number) => {
    const updated = images.map((img, i) => ({
      ...img,
      isPrimary: i === index,
    }));
    setImages(updated);
  };

  // ✨ VARIANT HANDLERS (with auto-copy from previous)
  const addVariant = () => {
    const lastVariant = variants[variants.length - 1];
    
    // ✨ Copy data from last variant if exists
    const newVariant: VariantInput = lastVariant ? {
      id: Math.random().toString(36).substring(7),
      title: "",
      sku: "",
      selectedSizes: [...lastVariant.selectedSizes],          // ✨ Copy sizes
      selectedColors: [...lastVariant.selectedColors],        // ✨ Copy colors
      selectedMaterials: [...lastVariant.selectedMaterials],  // ✨ Copy materials
      selectedMadeIn: [...lastVariant.selectedMadeIn],        // ✨ Copy made in
      customOptions: { ...lastVariant.customOptions },
      weight_grams: lastVariant.weight_grams,                 // ✨ Copy weight
      price_override: lastVariant.price_override,
      initial_stock: "",                                       // Don't copy stock
    } : {
      id: Math.random().toString(36).substring(7),
      title: "",
      sku: "",
      selectedSizes: [],
      selectedColors: [],
      selectedMaterials: [],
      selectedMadeIn: [],
      customOptions: {},
      weight_grams: "",
      price_override: "",
      initial_stock: "",
    };

    setVariants([...variants, newVariant]);
  };

  const updateVariant = (id: string, field: keyof VariantInput, value: any) => {
    setVariants(variants.map(v => (v.id === id ? { ...v, [field]: value } : v)));
  };

  const toggleVariantSize = (variantId: string, sizeId: string) => {
    setVariants(variants.map(v => {
      if (v.id !== variantId) return v;
      const has = v.selectedSizes.includes(sizeId);
      return {
        ...v,
        selectedSizes: has 
          ? v.selectedSizes.filter(id => id !== sizeId)
          : [...v.selectedSizes, sizeId]
      };
    }));
  };

  const toggleVariantColor = (variantId: string, colorId: string) => {
    setVariants(variants.map(v => {
      if (v.id !== variantId) return v;
      const has = v.selectedColors.includes(colorId);
      return {
        ...v,
        selectedColors: has 
          ? v.selectedColors.filter(id => id !== colorId)
          : [...v.selectedColors, colorId]
      };
    }));
  };

  // ✨ NEW: Toggle material
  const toggleVariantMaterial = (variantId: string, materialId: string) => {
    setVariants(variants.map(v => {
      if (v.id !== variantId) return v;
      const has = v.selectedMaterials.includes(materialId);
      return {
        ...v,
        selectedMaterials: has 
          ? v.selectedMaterials.filter(id => id !== materialId)
          : [...v.selectedMaterials, materialId]
      };
    }));
  };

  // ✨ NEW: Toggle made in
  const toggleVariantMadeIn = (variantId: string, madeInId: string) => {
    setVariants(variants.map(v => {
      if (v.id !== variantId) return v;
      const has = v.selectedMadeIn.includes(madeInId);
      return {
        ...v,
        selectedMadeIn: has 
          ? v.selectedMadeIn.filter(id => id !== madeInId)
          : [...v.selectedMadeIn, madeInId]
      };
    }));
  };

  const updateVariantCustomOption = (variantId: string, key: string, value: string) => {
    setVariants(variants.map(v => {
      if (v.id !== variantId) return v;
      return {
        ...v,
        customOptions: { ...v.customOptions, [key]: value }
      };
    }));
  };

  const removeVariant = (id: string) => {
    setVariants(variants.filter(v => v.id !== id));
  };

  // Build final options JSON
  const buildVariantOptions = (variant: VariantInput) => {
    const options: Record<string, any> = {};

    if (variant.selectedSizes.length > 0) {
      const sizeVals = variant.selectedSizes
        .map(id => availableSizes.find(s => s.id === id)?.value)
        .filter(Boolean);
      options.size = sizeVals.length === 1 ? sizeVals[0] : sizeVals.join(", ");
    }

    if (variant.selectedColors.length > 0) {
      const colorObjs = variant.selectedColors
        .map(id => availableColors.find(c => c.id === id))
        .filter(Boolean);
      
      if (colorObjs.length === 1) {
        options.color = { name: colorObjs[0].name, hex: colorObjs[0].hex };
      } else {
        options.colors = colorObjs.map(c => ({ name: c.name, hex: c.hex }));
      }
    }

    // ✨ NEW: Add material
    if (variant.selectedMaterials.length > 0) {
      const materialVals = variant.selectedMaterials
        .map(id => availableMaterials.find(m => m.id === id)?.value)
        .filter(Boolean);
      options.material = materialVals.length === 1 ? materialVals[0] : materialVals.join(", ");
    }

    // ✨ NEW: Add made_in
    if (variant.selectedMadeIn.length > 0) {
      const madeInVals = variant.selectedMadeIn
        .map(id => availableMadeIn.find(m => m.id === id)?.value)
        .filter(Boolean);
      options.made_in = madeInVals.length === 1 ? madeInVals[0] : madeInVals.join(", ");
    }

    Object.entries(variant.customOptions).forEach(([key, value]) => {
      if (value.trim()) {
        options[key] = value;
      }
    });

    return options;
  };

  const toggleCategory = (id: string) => {
    setSelectedCategoryIds((prev) => (prev.includes(id) ? prev.filter((x) => x !== id) : [...prev, id]));
  };

  const toggleCollection = (id: string) => {
    setSelectedCollectionIds((prev) => (prev.includes(id) ? prev.filter((x) => x !== id) : [...prev, id]));
  };

  const renderCategoryTree = (nodes: CategoryNode[], depth = 0) => {
    return (
      <div className="space-y-1">
        {nodes.map((n) => {
          const label = n.name ?? n.title ?? n.label ?? n.slug ?? "Untitled";
          const hasChildren = (n.children?.length ?? 0) > 0;
          const checked = selectedCategoryIds.includes(n.id);

          return (
            <div key={n.id}>
              <label
                className="flex items-center gap-2 text-sm"
                style={{ paddingLeft: `${depth * 12}px` }}
              >
                <input type="checkbox" checked={checked} onChange={() => toggleCategory(n.id)} />
                <span>{label}</span>
              </label>
              {hasChildren ? <div className="mt-1">{renderCategoryTree(n.children!, depth + 1)}</div> : null}
            </div>
          );
        })}
      </div>
    );
  };

  const create = async () => {
    if (!title.trim()) return toast.error("Title is required");

    const finalSlug = (slug.trim() || slugify(title)).trim();
    if (!finalSlug) return toast.error("Slug is required");

    if (cents === null || cents < 0) return toast.error("Price must be valid");

    setCreating(true);

    try {
      const res = await fetch("/api/products/admin", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title: title.trim(),
          slug: finalSlug,
          description: description.trim() ? description.trim() : null,
          price_cents: cents,
          status: "draft",
        }),
      });

      const json = await safeReadJson(res);
      if (!res.ok || !json?.ok) throw new Error(json?.error?.message ?? "Failed to create product");

      const productId = json.data?.id as string;
      if (!productId) throw new Error("Create succeeded but no product id returned");

      const createdVariantIds: string[] = [];
      
      for (const variant of variants) {
        const weightGrams = variant.weight_grams.trim() === "" ? null : Number(variant.weight_grams.trim());
        if (weightGrams !== null && (!Number.isFinite(weightGrams) || weightGrams < 0)) {
          throw new Error(`Invalid weight for variant: ${variant.title || variant.sku}`);
        }

        const overrideCents = variant.price_override.trim() === "" ? null : moneyToCents(variant.price_override.trim());
        if (overrideCents !== null && (overrideCents === null || overrideCents < 0)) {
          throw new Error(`Invalid price override for variant: ${variant.title || variant.sku}`);
        }

        const options = buildVariantOptions(variant);

        const vRes = await fetch(`/api/products/admin/${productId}/variants`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            title: variant.title.trim() || "Default",
            sku: variant.sku.trim() || null,
            options,
            weight_grams: weightGrams,
            price_cents: overrideCents,
          }),
        });

        const vJson = await safeReadJson(vRes);
        if (!vRes.ok || !vJson?.ok) {
          throw new Error(vJson?.error?.message ?? `Failed to create variant: ${variant.title || variant.sku}`);
        }

        const variantId = vJson.data?.id;
        if (variantId) {
          createdVariantIds.push(variantId);

          const stockQty = variant.initial_stock.trim() === "" ? null : Number(variant.initial_stock.trim());
          if (stockQty !== null) {
            if (!Number.isFinite(stockQty) || stockQty < 0) {
              throw new Error(`Invalid stock quantity for variant: ${variant.title || variant.sku}`);
            }

            const mRes = await fetch("/api/inventory/movements", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                variant_id: variantId,
                delta_qty: stockQty,
                reason: "initial",
                note: `Initial stock from product creation (${variant.title || variant.sku})`,
              }),
            });

            const mJson = await safeReadJson(mRes);
            if (!mRes.ok || !mJson?.ok) {
              throw new Error(mJson?.error?.message ?? "Failed to seed initial stock");
            }
          }
        }
      }

      if (selectedCategoryIds.length) {
        await Promise.all(
          selectedCategoryIds.map(async (category_id) => {
            const r = await fetch(`/api/products/admin/${productId}/categories`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ category_id }),
            });
            const j = await safeReadJson(r);
            if (!r.ok || !j?.ok) throw new Error(j?.error?.message ?? "Failed to assign category");
          })
        );
      }

      if (selectedCollectionIds.length) {
        await Promise.all(
          selectedCollectionIds.map(async (collection_id) => {
            const r = await fetch(`/api/products/admin/${productId}/collections`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ collection_id }),
            });
            const j = await safeReadJson(r);
            if (!r.ok || !j?.ok) throw new Error(j?.error?.message ?? "Failed to assign collection");
          })
        );
      }

      if (images.length) {
        const supabase = createBrowserClient();

        for (let i = 0; i < images.length; i++) {
          const img = images[i];
          const ext = safeExtFromFile(img.file);
          const object_path = buildObjectPath(productId, i + 1, ext);

          const up = await supabase.storage.from(PRODUCT_IMAGE_BUCKET).upload(object_path, img.file, {
            upsert: false,
            cacheControl: "3600",
            contentType: img.file.type || "application/octet-stream",
          });

          if (up.error) throw new Error(up.error.message);

          const r2 = await fetch(`/api/products/admin/${productId}/images`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              bucket_name: PRODUCT_IMAGE_BUCKET,
              object_path,
              alt_text: img.alt.trim() || null,
              position: img.position,
              is_primary: img.isPrimary,
            }),
          });

          const j2 = await safeReadJson(r2);
          if (!r2.ok || !j2?.ok) {
            throw new Error(j2?.error?.message ?? `Failed to create image row (${r2.status})`);
          }
        }
      }

      const bits: string[] = [];
      if (variants.length) bits.push(`${variants.length} variant${variants.length === 1 ? "" : "s"}`);
      if (selectedCategoryIds.length) bits.push(`${selectedCategoryIds.length} categor${selectedCategoryIds.length === 1 ? "y" : "ies"}`);
      if (selectedCollectionIds.length) bits.push(`${selectedCollectionIds.length} collection${selectedCollectionIds.length === 1 ? "" : "s"}`);
      if (images.length) bits.push(`${images.length} image${images.length === 1 ? "" : "s"}`);

      toast.success(bits.length ? `Product created with ${bits.join(", ")}` : "Product created");

      onOpenChange(false);
      onCreated();
      reset();
    } catch (e: any) {
      console.error(e);
      toast.error(e?.message ?? "Create failed");
    } finally {
      setCreating(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Create Product</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <div className="space-y-2">
            <label className="text-sm font-semibold">Title</label>
            <Input value={title} onChange={(e) => setTitle(e.target.value)} />
          </div>

          <div className="space-y-2">
            <label className="text-sm font-semibold">Slug</label>
            <div className="flex gap-2">
              <Input value={slug} onChange={(e) => setSlug(e.target.value)} />
              <Button type="button" variant="secondary" onClick={autoSlug}>
                Auto
              </Button>
            </div>
          </div>

          <div className="space-y-2">
            <label className="text-sm font-semibold">Price (USD)</label>
            <Input value={price} onChange={(e) => setPrice(e.target.value)} />
          </div>

          <div className="space-y-2">
            <label className="text-sm font-semibold">Description</label>
            <Textarea value={description} onChange={(e) => setDescription(e.target.value)} />
          </div>

          {/* Images */}
          <CollapsibleSection
            title="Images (optional)"
            description="Upload images with individual alt text for each."
            open={secImagesOpen}
            onToggle={() => setSecImagesOpen((v) => !v)}
          >
            <div className="space-y-3">
              <Input
                type="file"
                accept="image/*"
                multiple
                onChange={(e) => handleFilesSelected(e.target.files)}
              />

              {images.length > 0 && (
                <div className="space-y-2">
                  {images.map((img, idx) => (
                    <div key={idx} className="flex gap-3 items-start border border-[hsl(var(--border))] rounded-lg p-3">
                      <img
                        src={img.preview}
                        alt={img.alt || "Preview"}
                        className="w-20 h-20 object-cover rounded"
                      />
                      <div className="flex-1 space-y-2">
                        <Input
                          value={img.alt}
                          onChange={(e) => updateImageAlt(idx, e.target.value)}
                          placeholder={`Alt text for image ${idx + 1}`}
                        />
                        <div className="flex items-center gap-2 text-xs text-[hsl(var(--muted-foreground))]">
                          <span>Position: {img.position}</span>
                          {img.isPrimary && (
                            <span className="px-2 py-0.5 bg-blue-100 text-blue-700 rounded">Primary</span>
                          )}
                          {!img.isPrimary && (
                            <Button
                              type="button"
                              size="sm"
                              variant="ghost"
                              onClick={() => setPrimaryImage(idx)}
                            >
                              Set as Primary
                            </Button>
                          )}
                        </div>
                      </div>
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={() => removeImage(idx)}
                      >
                        <X size={16} />
                      </Button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </CollapsibleSection>

          {/* Variants */}
          <CollapsibleSection
            title="Variants (optional)"
            description="Define sizes, colors, materials, made in, and create variants with flexible options."
            open={secVariantsOpen}
            onToggle={() => setSecVariantsOpen((v) => !v)}
          >
            <div className="space-y-4">
              {/* Sizes */}
              <div className="border border-[hsl(var(--border))] rounded-lg p-3 space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-semibold">Available Sizes</label>
                  <Button type="button" size="sm" variant="outline" onClick={addSize}>
                    <Plus size={14} className="mr-1" /> Add Size
                  </Button>
                </div>
                {availableSizes.length === 0 && (
                  <p className="text-xs text-[hsl(var(--muted-foreground))]">No sizes defined. Add sizes if needed.</p>
                )}
                <div className="space-y-2">
                  {availableSizes.map((size) => (
                    <div key={size.id} className="flex gap-2 items-center">
                      <Input
                        value={size.value}
                        onChange={(e) => updateSize(size.id, e.target.value)}
                        placeholder="S, M, L, XL"
                        className="flex-1"
                      />
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={() => removeSize(size.id)}
                      >
                        <X size={14} />
                      </Button>
                    </div>
                  ))}
                </div>
              </div>

              {/* Colors */}
              <div className="border border-[hsl(var(--border))] rounded-lg p-3 space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-semibold">Available Colors</label>
                  <Button type="button" size="sm" variant="outline" onClick={addColor}>
                    <Plus size={14} className="mr-1" /> Add Color
                  </Button>
                </div>
                {availableColors.length === 0 && (
                  <p className="text-xs text-[hsl(var(--muted-foreground))]">No colors defined. Add colors if needed.</p>
                )}
                <div className="space-y-2">
                  {availableColors.map((color) => (
                    <div key={color.id} className="flex gap-2 items-center">
                      <Input
                        value={color.name}
                        onChange={(e) => updateColor(color.id, "name", e.target.value)}
                        placeholder="Brown, Blue, Black"
                        className="flex-1"
                      />
                      <Input
                        type="color"
                        value={color.hex}
                        onChange={(e) => updateColor(color.id, "hex", e.target.value)}
                        className="w-20"
                      />
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={() => removeColor(color.id)}
                      >
                        <X size={14} />
                      </Button>
                    </div>
                  ))}
                </div>
              </div>

              {/* ✨ NEW: Materials */}
              <div className="border border-[hsl(var(--border))] rounded-lg p-3 space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-semibold">Available Materials</label>
                  <Button type="button" size="sm" variant="outline" onClick={addMaterial}>
                    <Plus size={14} className="mr-1" /> Add Material
                  </Button>
                </div>
                {availableMaterials.length === 0 && (
                  <p className="text-xs text-[hsl(var(--muted-foreground))]">No materials defined. Add materials if needed.</p>
                )}
                <div className="space-y-2">
                  {availableMaterials.map((material) => (
                    <div key={material.id} className="flex gap-2 items-center">
                      <Input
                        value={material.value}
                        onChange={(e) => updateMaterial(material.id, e.target.value)}
                        placeholder="95%Polyester+5%Elastane, 100% Cotton"
                        className="flex-1"
                      />
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={() => removeMaterial(material.id)}
                      >
                        <X size={14} />
                      </Button>
                    </div>
                  ))}
                </div>
              </div>

              {/* ✨ NEW: Made In */}
              <div className="border border-[hsl(var(--border))] rounded-lg p-3 space-y-2">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-semibold">Available Made In</label>
                  <Button type="button" size="sm" variant="outline" onClick={addMadeIn}>
                    <Plus size={14} className="mr-1" /> Add Made In
                  </Button>
                </div>
                {availableMadeIn.length === 0 && (
                  <p className="text-xs text-[hsl(var(--muted-foreground))]">No made in locations defined. Add if needed.</p>
                )}
                <div className="space-y-2">
                  {availableMadeIn.map((madeIn) => (
                    <div key={madeIn.id} className="flex gap-2 items-center">
                      <Input
                        value={madeIn.value}
                        onChange={(e) => updateMadeIn(madeIn.id, e.target.value)}
                        placeholder="USA, China"
                        className="flex-1"
                      />
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={() => removeMadeIn(madeIn.id)}
                      >
                        <X size={14} />
                      </Button>
                    </div>
                  ))}
                </div>
              </div>

              {/* Individual Variants */}
              {variants.map((variant, idx) => (
                <div key={variant.id} className="border-2 border-[hsl(var(--border))] rounded-lg p-4 space-y-3">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-semibold">Variant {idx + 1}</h4>
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() => removeVariant(variant.id)}
                    >
                      <X size={16} />
                    </Button>
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div className="space-y-2">
                      <label className="text-xs font-semibold">Title</label>
                      <Input
                        value={variant.title}
                        onChange={(e) => updateVariant(variant.id, "title", e.target.value)}
                        placeholder="e.g., Brown - Small"
                      />
                    </div>

                    <div className="space-y-2">
                      <label className="text-xs font-semibold">SKU</label>
                      <Input
                        value={variant.sku}
                        onChange={(e) => updateVariant(variant.id, "sku", e.target.value)}
                        placeholder="LC2542552-P1720-S (or leave blank)"
                      />
                    </div>

                    {/* Size Selection */}
                    {availableSizes.length > 0 && (
                      <div className="space-y-2 md:col-span-2">
                        <label className="text-xs font-semibold">Sizes (select one or more)</label>
                        <div className="flex flex-wrap gap-2">
                          {availableSizes.map((size) => (
                            <Button
                              key={size.id}
                              type="button"
                              size="sm"
                              variant={variant.selectedSizes.includes(size.id) ? "default" : "outline"}
                              onClick={() => toggleVariantSize(variant.id, size.id)}
                            >
                              {size.value || "Unnamed"}
                            </Button>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* Color Selection */}
                    {availableColors.length > 0 && (
                      <div className="space-y-2 md:col-span-2">
                        <label className="text-xs font-semibold">Colors (select one or more)</label>
                        <div className="flex flex-wrap gap-2">
                          {availableColors.map((color) => (
                            <Button
                              key={color.id}
                              type="button"
                              size="sm"
                              variant={variant.selectedColors.includes(color.id) ? "default" : "outline"}
                              onClick={() => toggleVariantColor(variant.id, color.id)}
                              className="flex items-center gap-2"
                            >
                              <span
                                className="w-4 h-4 rounded border border-gray-300"
                                style={{ backgroundColor: color.hex }}
                              />
                              {color.name || "Unnamed"}
                            </Button>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* ✨ Material Selection */}
                    {availableMaterials.length > 0 && (
                      <div className="space-y-2 md:col-span-2">
                        <label className="text-xs font-semibold">Materials (select one or more)</label>
                        <div className="flex flex-wrap gap-2">
                          {availableMaterials.map((material) => (
                            <Button
                              key={material.id}
                              type="button"
                              size="sm"
                              variant={variant.selectedMaterials.includes(material.id) ? "default" : "outline"}
                              onClick={() => toggleVariantMaterial(variant.id, material.id)}
                            >
                              {material.value || "Unnamed"}
                            </Button>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* ✨ Made In Selection */}
                    {availableMadeIn.length > 0 && (
                      <div className="space-y-2 md:col-span-2">
                        <label className="text-xs font-semibold">Made In (select one or more)</label>
                        <div className="flex flex-wrap gap-2">
                          {availableMadeIn.map((madeIn) => (
                            <Button
                              key={madeIn.id}
                              type="button"
                              size="sm"
                              variant={variant.selectedMadeIn.includes(madeIn.id) ? "default" : "outline"}
                              onClick={() => toggleVariantMadeIn(variant.id, madeIn.id)}
                            >
                              {madeIn.value || "Unnamed"}
                            </Button>
                          ))}
                        </div>
                      </div>
                    )}

                    <div className="space-y-2">
                      <label className="text-xs font-semibold">Weight (grams)</label>
                      <Input
                        value={variant.weight_grams}
                        onChange={(e) => updateVariant(variant.id, "weight_grams", e.target.value)}
                        placeholder="310.01"
                      />
                    </div>

                    <div className="space-y-2">
                      <label className="text-xs font-semibold">Initial Stock</label>
                      <Input
                        value={variant.initial_stock}
                        onChange={(e) => updateVariant(variant.id, "initial_stock", e.target.value)}
                        placeholder="23"
                      />
                    </div>

                    <div className="space-y-2 md:col-span-2">
                      <label className="text-xs font-semibold">Price Override (optional)</label>
                      <Input
                        value={variant.price_override}
                        onChange={(e) => updateVariant(variant.id, "price_override", e.target.value)}
                        placeholder="blank = inherit product price"
                      />
                    </div>
                  </div>
                </div>
              ))}

              <Button type="button" onClick={addVariant} variant="outline" className="w-full">
                + Add Variant {variants.length > 0 && "(copies from previous)"}
              </Button>

              <div className="text-xs text-[hsl(var(--muted-foreground))]">
                Define sizes, colors, materials, and made in above, then select them for each variant. 
                New variants automatically copy settings from the previous variant.
              </div>
            </div>
          </CollapsibleSection>

          <CollapsibleSection
            title="Categories (optional)"
            description="Assign categories now (no category creation here)."
            open={secCategoriesOpen}
            onToggle={() => setSecCategoriesOpen((v) => !v)}
          >
            {!availableCategories.length ? (
              <div className="text-sm text-[hsl(var(--muted-foreground))]">
                No categories loaded yet (or none exist).
              </div>
            ) : (
              <div className="max-h-[260px] overflow-auto pr-2">
                {renderCategoryTree(availableCategories)}
              </div>
            )}
          </CollapsibleSection>

          <CollapsibleSection
            title="Collections (optional)"
            description="Assign collections now (no collection creation here)."
            open={secCollectionsOpen}
            onToggle={() => setSecCollectionsOpen((v) => !v)}
          >
            {!availableCollections.length ? (
              <div className="text-sm text-[hsl(var(--muted-foreground))]">
                No collections loaded yet (or none exist).
              </div>
            ) : (
              <div className="space-y-2 max-h-[260px] overflow-auto pr-2">
                {availableCollections.map((c) => {
                  const label = c.name ?? c.title ?? c.label ?? c.slug ?? "Untitled";
                  const checked = selectedCollectionIds.includes(c.id);
                  const home = Boolean((c as any).is_home_section ?? (c as any).is_homepage);
                  return (
                    <label key={c.id} className="flex items-center gap-2 text-sm">
                      <input type="checkbox" checked={checked} onChange={() => toggleCollection(c.id)} />
                      <span className="flex items-center gap-2">
                        {label}
                        {home ? (
                          <span className="text-xs rounded-full border border-[hsl(var(--border))] px-2 py-0.5 text-[hsl(var(--muted-foreground))]">
                            homepage
                          </span>
                        ) : null}
                      </span>
                    </label>
                  );
                })}
              </div>
            )}
          </CollapsibleSection>

          <div className="flex justify-end gap-2">
            <Button
              variant="secondary"
              onClick={() => {
                onOpenChange(false);
                reset();
              }}
              disabled={creating}
            >
              Cancel
            </Button>
            <Button onClick={create} disabled={creating}>
              {creating ? "Creating…" : "Create"}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
